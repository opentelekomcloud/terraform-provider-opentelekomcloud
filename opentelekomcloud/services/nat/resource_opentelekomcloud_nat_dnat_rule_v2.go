// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://www.github.com/huaweicloud/magic-modules
//
// ----------------------------------------------------------------------------

package nat

import (
	"context"
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	golangsdk "github.com/opentelekomcloud/gophertelekomcloud"
	"github.com/opentelekomcloud/gophertelekomcloud/openstack/networking/v2/ports"

	"github.com/opentelekomcloud/terraform-provider-opentelekomcloud/opentelekomcloud/common"
	"github.com/opentelekomcloud/terraform-provider-opentelekomcloud/opentelekomcloud/common/cfg"
	"github.com/opentelekomcloud/terraform-provider-opentelekomcloud/opentelekomcloud/common/fmterr"
)

func ResourceNatDnatRuleV2() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceNatDnatRuleCreate,
		ReadContext:   resourceNatDnatRuleRead,
		DeleteContext: resourceNatDnatRuleDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Schema: map[string]*schema.Schema{
			"floating_ip_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"internal_service_port": {
				Type:     schema.TypeInt,
				Required: true,
				ForceNew: true,
			},

			"nat_gateway_id": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"port_id": {
				Type:          schema.TypeString,
				ConflictsWith: []string{"private_ip"},
				Optional:      true,
				ForceNew:      true,
			},

			"private_ip": {
				Type:          schema.TypeString,
				ConflictsWith: []string{"port_id"},
				Optional:      true,
				ForceNew:      true,
			},

			"protocol": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
			},

			"external_service_port": {
				Type:     schema.TypeInt,
				Required: true,
				ForceNew: true,
			},

			"created_at": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"floating_ip_address": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"status": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"tenant_id": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func resourceNatDnatUserInputParams(d *schema.ResourceData) map[string]interface{} {
	return map[string]interface{}{
		"external_service_port": d.Get("external_service_port"),
		"floating_ip_id":        d.Get("floating_ip_id"),
		"internal_service_port": d.Get("internal_service_port"),
		"nat_gateway_id":        d.Get("nat_gateway_id"),
		"port_id":               d.Get("port_id"),
		"private_ip":            d.Get("private_ip"),
		"protocol":              d.Get("protocol"),
	}
}

func waitForPortToActivate(ctx context.Context, d *schema.ResourceData, meta interface{}, portID string) error {
	config := meta.(*cfg.Config)
	client, err := config.NetworkingV2Client(config.GetRegion(d))
	if err != nil {
		return fmt.Errorf("error creating NetworkingV2 client: %w", err)
	}
	stateConf := &resource.StateChangeConf{
		Target:     []string{"ACTIVE"},
		Refresh:    getNetworkPortState(client, portID),
		Timeout:    d.Timeout(schema.TimeoutCreate),
		Delay:      5 * time.Second,
		MinTimeout: 3 * time.Second,
	}

	_, err = stateConf.WaitForStateContext(ctx)
	if err != nil {
		return fmt.Errorf("error waiting for OpenTelekomCloud Neutron port to activate: %w", err)
	}
	return nil
}

func getNetworkPortState(client *golangsdk.ServiceClient, portId string) resource.StateRefreshFunc {
	return func() (interface{}, string, error) {
		p, err := ports.Get(client, portId).Extract()
		if err != nil {
			return nil, "", err
		}

		log.Printf("[DEBUG] OpenTelekomCloud Neutron Port: %+v", p)
		if p.Status == "DOWN" || p.Status == "ACTIVE" {
			return p, "ACTIVE", nil
		}

		return p, p.Status, nil
	}
}

func resourceNatDnatRuleCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	config := meta.(*cfg.Config)
	client, err := config.NatV2Client(config.GetRegion(d))
	if err != nil {
		return fmterr.Errorf("error creating sdk client, err=%s", err)
	}

	opts := resourceNatDnatUserInputParams(d)

	params := make(map[string]interface{})

	floatingIPIDProp, err := common.NavigateValue(opts, []string{"floating_ip_id"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err := common.IsEmptyValue(reflect.ValueOf(floatingIPIDProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["floating_ip_id"] = floatingIPIDProp
	}

	internalServicePortProp, err := common.NavigateValue(opts, []string{"internal_service_port"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(internalServicePortProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["internal_service_port"] = internalServicePortProp
	}

	externalServicePortProp, err := common.NavigateValue(opts, []string{"external_service_port"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(externalServicePortProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["external_service_port"] = externalServicePortProp
	}

	natGatewayIDProp, err := common.NavigateValue(opts, []string{"nat_gateway_id"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(natGatewayIDProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["nat_gateway_id"] = natGatewayIDProp
	}

	portIDProp, err := common.NavigateValue(opts, []string{"port_id"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(portIDProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["port_id"] = portIDProp
		if err := waitForPortToActivate(ctx, d, meta, portIDProp.(string)); err != nil {
			return diag.FromErr(err)
		}
	}

	privateIPProp, err := common.NavigateValue(opts, []string{"private_ip"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(privateIPProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["private_ip"] = privateIPProp
	}

	protocolProp, err := common.NavigateValue(opts, []string{"protocol"}, nil)
	if err != nil {
		return diag.FromErr(err)
	}
	e, err = common.IsEmptyValue(reflect.ValueOf(protocolProp))
	if err != nil {
		return diag.FromErr(err)
	}
	if !e {
		params["protocol"] = protocolProp
	}

	log.Printf("[DEBUG] Creating new Dnat: %#v", params)

	url, err := common.ReplaceVars(d, "dnat_rules", nil)
	if err != nil {
		return diag.FromErr(err)
	}
	url = client.ServiceURL(url)

	r := golangsdk.Result{}
	_, r.Err = client.Post(
		url,
		&map[string]interface{}{"dnat_rule": params},
		&r.Body,
		&golangsdk.RequestOpts{OkCodes: common.SuccessHTTPCodes})
	if r.Err != nil {
		return fmterr.Errorf("error creating Dnat: %s", r.Err)
	}

	id, err := common.NavigateValue(r.Body, []string{"dnat_rule", "id"}, nil)
	if err != nil {
		return fmterr.Errorf("error constructing id: %s", err)
	}
	d.SetId(id.(string))

	return resourceNatDnatRuleRead(ctx, d, meta)
}

func resourceNatDnatRuleRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	config := meta.(*cfg.Config)
	client, err := config.NatV2Client(config.GetRegion(d))
	if err != nil {
		return fmterr.Errorf("error creating sdk client, err=%s", err)
	}

	url, err := common.ReplaceVars(d, "dnat_rules/{id}", nil)
	if err != nil {
		return diag.FromErr(err)
	}
	url = client.ServiceURL(url)

	r := golangsdk.Result{}
	_, r.Err = client.Get(
		url, &r.Body,
		&golangsdk.RequestOpts{MoreHeaders: map[string]string{"Accept": "application/json"}})
	if r.Err != nil {
		return fmterr.Errorf("error reading %s: %s", fmt.Sprintf("NatDnat %q", d.Id()), r.Err)
	}
	v, ok := r.Body.(map[string]interface{})
	if !ok {
		return fmterr.Errorf("error reading %s: the result is not map", fmt.Sprintf("NatDnat %q", d.Id()))
	}

	res := map[string]interface{}{"read": v}

	opts := resourceNatDnatUserInputParams(d)

	createdATProp, err := common.NavigateValue(res, []string{"read", "dnat_rule", "created_at"}, nil)
	if err != nil {
		return fmterr.Errorf("error reading Dnat:created_at, err: %s", err)
	}
	if err = d.Set("created_at", createdATProp); err != nil {
		return fmterr.Errorf("error setting Dnat:created_at, err: %s", err)
	}

	floatingIPIDProp, ok := opts["floating_ip_id"]
	if floatingIPIDProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(floatingIPIDProp))
		ok = !ok
	}
	if !ok {
		floatingIPIDProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "floating_ip_id"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:floating_ip_id, err: %s", err)
		}
		if err = d.Set("floating_ip_id", floatingIPIDProp); err != nil {
			return fmterr.Errorf("error setting Dnat:floating_ip_id, err: %s", err)
		}
	}

	floatingIPAddrProp, err := common.NavigateValue(res, []string{"read", "dnat_rule", "floating_ip_address"}, nil)
	if err != nil {
		return fmterr.Errorf("error reading Dnat:floating_ip_address, err: %s", err)
	}
	if err = d.Set("floating_ip_address", floatingIPAddrProp); err != nil {
		return fmterr.Errorf("error setting Dnat:floating_ip_address, err: %s", err)
	}

	internalServicePortProp, ok := opts["internal_service_port"]
	if internalServicePortProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(internalServicePortProp))
		ok = !ok
	}
	if !ok {
		internalServicePortProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "internal_service_port"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:internal_service_port, err: %s", err)
		}
		if err = d.Set("internal_service_port", internalServicePortProp); err != nil {
			return fmterr.Errorf("error setting Dnat:internal_service_port, err: %s", err)
		}
	}

	externalServicePortProp, ok := opts["external_service_port"]
	if externalServicePortProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(externalServicePortProp))
		ok = !ok
	}
	if !ok {
		externalServicePortProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "external_service_port"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:external_service_port, err: %s", err)
		}
		if err = d.Set("external_service_port", externalServicePortProp); err != nil {
			return fmterr.Errorf("error setting Dnat:external_service_port, err: %s", err)
		}
	}

	natGatewayIDProp, ok := opts["nat_gateway_id"]
	if natGatewayIDProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(natGatewayIDProp))
		ok = !ok
	}
	if !ok {
		natGatewayIDProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "nat_gateway_id"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:nat_gateway_id, err: %s", err)
		}
		if err = d.Set("nat_gateway_id", natGatewayIDProp); err != nil {
			return fmterr.Errorf("error setting Dnat:nat_gateway_id, err: %s", err)
		}
	}

	portIDProp, ok := opts["port_id"]
	if portIDProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(portIDProp))
		ok = !ok
	}
	if !ok {
		portIDProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "port_id"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:port_id, err: %s", err)
		}
		if err = d.Set("port_id", portIDProp); err != nil {
			return fmterr.Errorf("error setting Dnat:port_id, err: %s", err)
		}
	}

	privateIPProp, ok := opts["private_ip"]
	if privateIPProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(privateIPProp))
		ok = !ok
	}
	if !ok {
		privateIPProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "private_ip"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:private_ip, err: %s", err)
		}
		if err = d.Set("private_ip", privateIPProp); err != nil {
			return fmterr.Errorf("error setting Dnat:private_ip, err: %s", err)
		}
	}

	protocolProp, ok := opts["protocol"]
	if protocolProp != nil {
		ok, _ = common.IsEmptyValue(reflect.ValueOf(protocolProp))
		ok = !ok
	}
	if !ok {
		protocolProp, err = common.NavigateValue(res, []string{"read", "dnat_rule", "protocol"}, nil)
		if err != nil {
			return fmterr.Errorf("error reading Dnat:protocol, err: %s", err)
		}
		if err = d.Set("protocol", protocolProp); err != nil {
			return fmterr.Errorf("error setting Dnat:protocol, err: %s", err)
		}
	}

	statusProp, err := common.NavigateValue(res, []string{"read", "dnat_rule", "status"}, nil)
	if err != nil {
		return fmterr.Errorf("error reading Dnat:status, err: %s", err)
	}
	if err = d.Set("status", statusProp); err != nil {
		return fmterr.Errorf("error setting Dnat:status, err: %s", err)
	}

	tenantIDProp, err := common.NavigateValue(res, []string{"read", "dnat_rule", "tenant_id"}, nil)
	if err != nil {
		return fmterr.Errorf("error reading Dnat:tenant_id, err: %s", err)
	}
	if err = d.Set("tenant_id", tenantIDProp); err != nil {
		return fmterr.Errorf("error setting Dnat:tenant_id, err: %s", err)
	}

	return nil
}

func resourceNatDnatRuleDelete(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	config := meta.(*cfg.Config)
	client, err := config.NatV2Client(config.GetRegion(d))
	if err != nil {
		return fmterr.Errorf("error creating sdk client, err=%s", err)
	}

	url, err := common.ReplaceVars(d, "dnat_rules/{id}", nil)
	if err != nil {
		return diag.FromErr(err)
	}
	url = client.ServiceURL(url)

	log.Printf("[DEBUG] Deleting Dnat %q", d.Id())
	r := golangsdk.Result{}
	_, r.Err = client.Delete(url, &golangsdk.RequestOpts{
		OkCodes:      []int{204},
		JSONResponse: nil,
		MoreHeaders:  map[string]string{"Content-Type": "application/json"},
	})
	if r.Err != nil {
		return fmterr.Errorf("error deleting Dnat %q: %s", d.Id(), r.Err)
	}

	return nil
}
